1、抛出一个exception,程序暂停在exception抛出的地方，然后将程序的控制权和
(包含调用者可用于对异常操作的信息的)exception object传递给异常处理程序部分。
2、domain_error 在<stdexcept>库中，表示函数的参数超过函数可接受的值域。
### 3、reference相当于变量的别名
##### 非const 的reference不能成为Const obj或 reference的引用
##### const的reference可以成为const or non-const的引用	
##### 当一个函数的形参的类型为const &的时候，有两个含义：
##### 直接传入实参，而不是value-copy，并且保证不会改变形参的值。
### 如：
##### const int &p = q;
##### int &r = p; 是不被允许的。
##### const int *p
##### int *const p 的区别？

4、lvalue是一个指向非临时对象的值。变量，引用都是一个左值。
5、EOF指示符通常意味着input失败
6、对于istream object的clear()，重置任何失败指示符，使得input可以继续
对于vector object的clear(),清空vector.
7、非const 引用的参数必须是个左值，因为如果非const 引用的参数是个临时变量的话，
函数运行完，这个临时变量就消失了，起不到引用的作用，在函数内对这个引用的一些改变
毫无意义。
8、一次只在一个代码段里面出现一个side effect
9、头文件是C++里面一个真实的文件，系统头不一定是一个文件。头文件应该使用完整的
名称，而不是using declarations
## 第六章库算法
迭代器适配器：返回迭代器的函数，迭代器的属性和参数相关。
copy(begin,end,back_inserter(container))
从back_inserter返回的迭代器的位置开始复制[begin,end)的序列。

remove(begin,end,element)
从[begin,end)删除满足element的元素，返回最后一个元素之后下一个的迭代器

remove_copy(begin,end,destenation(iterator),element)
从[begin,end)排除掉满足element的元素之后复制到destenation位置，返回原序列
最后一个被复制的元素的下一个位置的迭代器。

remove_copy_if(begin,end,destenation(ietrator),predicate)
从[begin,end)删除满足predicate函数的元素，并将删除后的元素复制到destenation的位置，返回原序列最后一个被复制的元素的下一个位置的迭代器。

partition(begin,end,predicate)
使得满足predicate的元素排在[begin,end)序列的前面
不满足的排在后面，返回指向第一个不满足的元素的迭代器。
会改变各区域元素原来的相对顺序。
stable_partition(begin,end,predicate)
不会改变各区域元素原来的相对顺序
对于算法库里面的算法的理解：算法作用在容器的元素上，而非作用于容器。

##  第七章map
1、关联数组：关联式容器的一种，当把一个键值对插入到结构中时，这个键会一直
伴随这个值，直到删除这个键值对为止。
2、map：关联数组的一种，map的key必须是可以通过比较进行排序的类型
其中每一个元素都是一个pair，first指向key，second指向value,
pair<const key,value>，为什么key是const类型的，

##### 如果不是const就隐式地说明我们可以改变元素的位置，这与关联式容器的自排序不相符
##### 关联式容器和序列式容器的区别，关联式容器是自排序的
4、当我们用一个从来没有遇到过的key来做map的索引的时候：map[key]
map会自动创建一个包含该key的元素，并且进行值初始化，例如：int类型的值初始化为0

const map<key,value> 没有定义[]操作符

#### （与容器元素相关的初始化都是值初始化,vector的值初始化，和不显式地提供初始值创建一个vector的效果一样，都是创建一个空vector)

rand()生成伪随机数产生的问题：1、rand( )%2,可能会出现0，1交替出现的情况。2、rand( )%20000,如果rand产生的最大值为32767，则会有两个值让rand%20000为10000，（10000和30000）但是只有一个值让rand( )%20000为15000。每个数产生的概率不同。

c++的map是用B+树来实现的。


## 第八章 泛型
## 第九章 类
1、类的接口：类提供给 这个类的对象的 操作（就是操作这个类的对象的函数来访问数据）
2、打算让别人使用的代码尽可能少的包含必要的声明。
3、double grade() const；作为一个成员函数，这个const表示调用该成员函数不会改变
这个类的对象的任何数据成员。注意：只是保证不会改变这个成员函数所属的类的对象的
数据成员。
4、::生存空间操作符的使用, name space :: function name，通过这样来表明这个函数
所属的命名空间。如果name spcace空着不写，就表示这个函数不属于任何一个命名空间。
特别注意：如果在成员函数里面调用一个不属于该成员的同名函数，就必须：：function name这样写。
5、一个类的对象的成员函数（1）可以直接访问对象的数据元素。
                        (2)成员函数的调用里隐含着 一个 <成员函数所属的对象的引用> 的参数。
6、const关键字的理解：
double Student_info::grade() const{}：const 成员函数 表示成员函数不会修改它所操作的对象的数据成员。
double grade(const Student_info&){}:传入一个const参数，表明函数不会改变这个参数的值。
注意：如果把一个非const的对象std传给grade函数，grade(std)，那么std会被当作const对象来处理，此时就只能调用stu.grade()
而不能调用其他非const的成员函数。
const对象只能调用const 成员函数
7、什么时候设计成员函数：如果这个函数改变对象的数据成员时，就应该把这个函数设计为成员函数。
8、struct 和class的唯一区别：默认保护的方式不同。
struct会从{到第一个保护标签之前的所有成员视为public
class会从{到第一个保护标签之前的所有成员视为private
通常使用struct来表示简单的类型。
9、访问器函数：访问对象内部的数据成员的成员函数
10、构造函数：定义了对象如何初始化的函数。 如果没有定义构造函数就会使用编译器合成的构造函数
没有返回值，函数名与类名相同。
构造函数初始化对象的数据成员的规则：
    (1)类定义了构造函数，按照定义的构造函数来初始化
    (2)当创建的对象是局部变量时候，进行默认初始化(取决于变量的类型，如果一个变量的类型定义了如何默认初始化，就按照定义来，否则是不明确的值)

##### 当创建的对象和容器的元素相关的话，进行值初始化(内置类型值初始化为0)    场景：1、用来初始化容器的元素，2、作为给定长度容器的元素 3、map新添的一个元素，

(3)如果没有定义任何构造函数的类，对这个类的数据成员进行适当的默认初始化或者值初始化，数据成员的类型是个类的话，就递归的进行初始化。
11、默认构造函数：不带有任何参数的构造函数
构造函数的定义 Student_info::Student_info(): <初始化列表> {};初始化列表表示对象该如何初始化
创建一个对象进行的工作：1、系统为对象分配内存，2、使用构造函数的初始化列表，初始化对象，3、执行构造函数的函数体。
通过在初始化列表显式地进行初始化，可以避免在函数体进行两次初始化操作。
成员初始化的顺序取决于在类中声明的顺序。用数据成员b来初始化数据化成员a时，则必须a声明在b之前，安全的做法是在函数体里面进行初始化。

## 第十章：管理内存和底层数据结构

1、函数是一种类型，函数类型做右值时，自动转换为函数指针类型。

2、函数调用运算符（）要求操作数是函数指针

例如：void say(string str){

​	cout << str;

}

void *fp(string str) = say;

f("hi");

也可以这么写 say("hi"),(*f)("hi"),都会把函数类型转换为函数指针类型再做函数调用。。

不用太纠结函数指针，返回函数指针的函数，函数指针作为函数参数的情况。。

3、用const来做常量标识。const size_t NUM=3

4、字符串，用一个char 数组初始化string类型变量

string str(arry);会把char数组里面字符都复制到string变量里面不包括'\0'

string str(arrry,arry+strlen(arry));使用一个序列来初始化string变量，第一个迭代器指向序列的首字符，

第二个迭代器指向序列的最后一个字符的下一个位置。

5、字符指针数组：数组的元素是字符指针，每一个指针都指向一个字符串的地址

6、三种内存管理：

(1)自动内存管理，在局部变量创建时，给局部变量分配内存，在退出包含这个定义的语句块时

释放这个内存。释放之后，所有指向这个变量的指针都会无效。

(2)静态分配内存：通过static关键，在程序运行前先给变量分配一次内存

缺点：只要程序在运行，指向静态分配的内存就有效，但是分配的内存地址不会改变。

(3)动态分配内存：new T(args)：为类型T的对象分配内存，使用特定的值来初始化这个对象，

这个表达式会生成一个指向这个新对象的内存的指针p。如果args省略，则进行默认初始化。

直到执行delete  p；这个对象才会消失。

new T[nums]，为nums个T类型的对象的数组分配内存空间，返回一个T*指针，指向这个数组的首元素，

对数组里面每个对象进行值初始化。

new一个数组，所进行的初始化：如果是一个内置类型，是在局部生存空间分配的内存，对象没有被初始化

如果是一个类，每个元素都会通过默认构造函数进行初始化。

特别注意：1、当类不允许默认初始化时，编译器会结束程序。2、当为数组里面每个对象进行初始化，会带来

开销，所以不推荐使用new 一个数组。

new T[0]会返回一个越界指针，可以认为这个指针就是指向首元素应该指向的位置的指针。

delete []p,释放一个数组之前，会逆序释放数组的每个元素