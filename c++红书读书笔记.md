### 异常相关：
1、抛出一个exception,程序暂停在exception抛出的地方，然后将程序的控制权和
(包含调用者可用于对异常操作的信息的)exception object传递给异常处理程序部分。
2、domain_error 在<stdexcept>库中，表示函数的参数超过函数可接受的值域。

### 引用相关

### reference相当于变量的别名

| 形参类型| 实参类型|
| --- | --- |
| reference |左值（非临时性的对象）|
| const reference     |任意值|

##### 非const 的reference不能成为Const obj或 reference的引用
##### const的reference可以成为const or non-const的引用	
##### 当一个函数的形参的类型为const &的时候，有两个含义：
##### 直接传入实参，而不是value-copy，并且保证不会改变形参的值。
### 如：
##### const int &p = q;
##### int &r = p; 是不被允许的。
##### const int *p
##### int *const p 的区别？

tips:

1、lvalue是一个指向非临时对象的值。变量，引用都是一个左值。
2、EOF指示符通常意味着input失败
3、对于istream object的clear()，重置任何失败指示符，使得input可以继续
对于vector object的clear(),清空vector.
4、非const 引用的参数必须是个左值，因为如果非const 引用的参数是个临时变量的话，
函数运行完，这个临时变量就消失了，起不到引用的作用，在函数内对这个引用的一些改变
毫无意义。
5、一次只在一个代码段里面出现一个side effect
6、头文件是C++里面一个真实的文件，系统头不一定是一个文件。头文件应该使用完整的
名称，而不是using declarations

## 第六章库算法
迭代器适配器：返回迭代器的函数，迭代器的属性和参数相关。

#### 1、常用库算法：

copy(begin,end,back_inserter(container))
从back_inserter返回的迭代器的位置开始复制[begin,end)的序列。

remove(begin,end,element)
从[begin,end)删除满足element的元素，返回最后一个元素之后下一个的迭代器

remove_copy(begin,end,destenation(iterator),element)
从[begin,end)排除掉满足element的元素之后复制到destenation位置，返回原序列
最后一个被复制的元素的下一个位置的迭代器。

remove_copy_if(begin,end,destenation(ietrator),predicate)
从[begin,end)删除满足predicate函数的元素，并将删除后的元素复制到destenation的位置，返回原序列最后一个被复制的元素的下一个位置的迭代器。

partition(begin,end,predicate)
使得满足predicate的元素排在[begin,end)序列的前面
不满足的排在后面，返回指向第一个不满足的元素的迭代器。
会改变各区域元素原来的相对顺序。
stable_partition(begin,end,predicate)
不会改变各区域元素原来的相对顺序
对于算法库里面的算法的理解：算法作用在容器的元素上，而非作用于容器本身

back_inserter(c):为容器C生成一个迭代器，可以为C添加元素。容器必须支持push_back操作，如:vector,list,string

front_inserter(c):为容器c生成一个迭代器，从容器前面插入元素。容器必须支持front_back操作，如：list

inserter(c,it):为容器c生成一个迭代器，但是在it之前插入

#### 2、const_iterator,和iterator的区别：

const_iterator不能改变所指向的元素的值。

iterator可以改变指向的元素的值



##  第七章map
1、关联数组：关联式容器的一种，当把一个键值对插入到结构中时，这个键会一直
伴随这个值，直到删除这个键值对为止。
2、map：关联数组的一种，map的key必须是可以通过比较进行排序的类型
其中每一个元素都是一个pair，first指向key，second指向value,
pair<const key,value>，为什么key是const类型的，

##### 如果不是const就隐式地说明我们可以改变元素的位置，这与关联式容器的自排序不相符
##### 关联式容器和序列式容器的区别，关联式容器是自排序的
4、当我们用一个从来没有遇到过的key来做map的索引的时候：map[key]
map会自动创建一个包含该key的元素，并且进行值初始化，例如：int类型的值初始化为0

const map<key,value> 没有定义[]操作符

#### （与容器元素相关的初始化都是值初始化,vector的值初始化，和不显式地提供初始值创建一个vector的效果一样，都是创建一个空vector)

tips:

rand()生成伪随机数产生的问题：1、rand( )%2,可能会出现0，1交替出现的情况。2、rand( )%20000,如果rand产生的最大值为32767，则会有两个值让rand%20000为10000，（10000和30000）但是只有一个值让rand( )%20000为15000。每个数产生的概率不同。

c++的map是用B+树来实现的。

## 第八章 泛型

template <class T>

T median(vector<T> v)

{

​	typedef typename vector<T>::size_type vec_sz;

}

T为类型参数，和函数参数类似，代表着类型

1、模板函数的语言特性支持我们实现泛型函数。模板函数是为一族函数或者类型编写单独的定义。
不同类型的对象可以具有相同的行为。根据共同的行为来编写函数。
2、“泛型函数可以“接受任意适当类型的”参数”：
（1）使用参数的方式成为参数类型的约束条件，如：使用x+y就约束了参数x，y必须能够使得x+y被定义。
（2）标准库如何组织这种约束条件，如：使用的参数是迭代器类型来组织这种约束条件。这里的迭代器指：支持特定操作集的类型。
3、typename的使用,当使用的类型包含模板参数的时候,比如vector<T>,并且你要使用这个类型的成员同样也是个类型时，

vector<T>::size_type，就要在整个类型前面加上typename.

4、实例化取决于具体的编译器，（1）发生的时期：编译/链接期，所以链接期遇到的看起来像编译错误，可能是模板实例化导致的。（2）模板的定义必须可以访问。
5、模板参数的类型是从参数的类型推断出来的。

6、泛型函数使用迭代器作为参数的好处：  

​		（1）查找任意容器的连续部分的一个值

​		（2）使用迭代器可以访问特殊的，不在容器内的元素，比如rbegin函数，返回容器的最后一个元素的迭代器。减少库的复杂度

7、迭代器的种类和访问容器的策略相对应。

​	（1）顺序只读访问 -> 输入迭代器，满足  ++ , == , != , *  , ->这五种操作的类型称为输入迭代器

​	（2）顺序只写访问 -> 输出迭代器，满足 *dest=value,dest++这两种操作的类型称为输出迭代器。

​	（3）顺序读写访问 ->前向迭代器， 满足输出迭代器和输出迭代器支持的操作

​	  (4) 可逆读写访问   ->双向迭代器， 满足前向迭代器的所有操作，并支持--操作的迭代器。

​	  (5) 随机访问   ->  随机访问迭代器，  满足指针的所有操作。


## 第九章 类
1、类的接口：类提供给 这个类的对象的 操作（就是操作这个类的对象的函数来访问数据）
2、打算让别人使用的代码尽可能少的包含必要的声明。头文件中尽可能不使用using 声明
3、double grade() const；作为一个成员函数，这个const表示调用该成员函数不会改变
这个类的对象的任何数据成员。注意：只是保证不会改变这个成员函数所属的类的对象的
数据成员。

成员函数与普通函数的区别：

​    (1)、函数名变为：class name::function name

​    (2)、对象隐含在每次调用中，就不需要把对象作为参数传递给成员函数

​    (3)、成员函数可以直接访问对象内部的数据。

4、::生存空间操作符的使用, name space :: function name，通过这样来表明这个函数
所属的命名空间。如果name spcace空着不写，就表示这个函数不属于任何一个命名空间。
特别注意：如果在成员函数里面调用一个不属于该成员的同名函数，就必须：：function name这样写。

6、const关键字的理解：
double Student_info::grade() const{}：const 成员函数 表示成员函数不会修改它所操作的对象的内部状态。
double grade(const Student_info&){}:传入一个const参数，表明函数不会改变这个参数的值。

const成员函数的由来：由于成员函数不能通过参数列表来说明，调用这个函数的对象是否是const，所以只能限定这个函数本身。const成员函数不会改变它所属对象的值，出于同样的理由，一个const对象不能调用非const的成员函数，比如const stu不能调用read函数，因为这样会改变const属性。（const对象只能调用const 成员函数）

注意：如果把一个非const的对象stu传给grade函数，grade(stu)，那么stu会被当作const对象来处理，此时就只能调用stu.grade()而不能调用其他非const的成员函数。也就是说非const对象通过函数调用间接创建大量const对象的引用。


7、什么时候设计成员函数：如果这个函数改变对象的数据成员时，就应该把这个函数设计为成员函数。
8、struct 和class的唯一区别：默认保护的方式不同。
struct会从{到第一个保护标签之前的所有成员视为public
class会从{到第一个保护标签之前的所有成员视为private
通常使用struct来表示简单的类型。
9、访问器函数：访问对象内部的数据成员的成员函数
10、

#### 构造函数：定义了对象如何初始化的函数。 如果没有定义构造函数就会使用编译器合成的构造函数
没有返回值，函数名与类名相同。
构造函数初始化对象的数据成员的规则：
    (1)类定义了构造函数，按照定义的构造函数来初始化
    (2)当创建的对象是局部变量时候，进行默认初始化(取决于变量的类型，如果一个变量的类型定义了如何默认初始化，就按照定义来，否则是不明确的值)

##### 当创建的对象和容器的元素相关的话，进行值初始化(内置类型值初始化为0)    场景：1、用来初始化容器的元素，2、作为给定长度容器的元素 3、map新添的一个元素，

(3)如果没有定义任何构造函数的类，对这个类的数据成员进行适当的默认初始化或者值初始化，数据成员的类型是个类的话，就递归的进行初始化。
11、默认构造函数：不带有任何参数的构造函数
构造函数的定义 Student_info::Student_info(): <初始化列表> {};初始化列表表示对象该如何初始化
创建一个对象进行的工作：1、系统为对象分配内存，2、使用构造函数的初始化列表，初始化对象，3、执行构造函数的函数体。
通过在初始化列表显式地进行初始化，可以避免在函数体进行两次初始化操作。
成员初始化的顺序取决于在类中声明的顺序。用数据成员b来初始化数据化成员a时，则必须a声明在b之前，安全的做法是在函数体里面进行初始化。

## 第十章：管理内存和底层数据结构

1、函数是一种类型，函数类型做右值时，自动转换为函数指针类型。

2、函数调用运算符（）要求操作数是函数指针

例如：void say(string str){

​	cout << str;

}

void *fp(string str) = say;

f("hi");

也可以这么写 say("hi"),(*f)("hi"),都会把函数类型转换为函数指针类型再做函数调用。。

不用太纠结函数指针，返回函数指针的函数，函数指针作为函数参数的情况。。

3、用const来做常量标识。const size_t NUM=3

4、字符串，用一个char 数组初始化string类型变量

string str(arry);会把char数组里面字符都复制到string变量里面不包括'\0'

string str(arrry,arry+strlen(arry));使用一个序列来初始化string变量，第一个迭代器指向序列的首字符，

第二个迭代器指向序列的最后一个字符的下一个位置。

5、字符指针数组：数组的元素是字符指针，每一个指针都指向一个字符串的地址

6、三种内存管理：

(1)自动内存管理，在局部变量创建时，给局部变量分配内存，在退出包含这个定义的语句块时

释放这个内存。释放之后，所有指向这个变量的指针都会无效。

(2)静态分配内存：通过static关键字，在程序运行前先给变量分配一次内存

缺点：只要程序在运行，指向静态分配的内存就有效，但是分配的内存地址不会改变。

(3)动态分配内存：new T(args)：为类型T的对象分配内存，使用特定的值来初始化这个对象，

这个表达式会生成一个指向这个新对象的内存的指针p。如果args省略，则进行默认初始化。

直到执行delete  p；这个对象才会消失。

new T[nums]，为nums个T类型的对象的数组分配内存空间，返回一个T*指针，指向这个数组的首元素，

对数组里面每个对象进行值初始化。

#### new一个数组，所进行的初始化：如果T是一个内置类型，是在局部生存空间分配的内存，对象没有被初始化

#### 如果T是一个类，每个元素都会通过默认构造函数进行初始化。

#### 特别注意：1、当类不允许默认初始化时，编译器会结束程序。（相当于给这个类强加一条约束：类必须要有一个默认构造函数）2、当为数组里面每个对象进行初始化，会带来额外开销，所以不推荐使用new 一个数组。

new T[0]会返回一个越界指针，可以认为这个指针就是指向首元素应该指向的位置的指针。

delete []p,释放一个数组之前，会逆序释放数组的每个元素

## 第11章定义抽象数据类型

#### 对类的控制：创建，复制，赋值，销毁四个过程

（构造函数，复制构造函数，赋值操作符，析构函数）

复制构造函数：定义了类的复制的过程。
显式复制：用一个对象初始化一个新的对象   new_obj = obj;

隐式复制：把对象的值传入一个函数中，从一个函数中返回一个对象的值。
对于复制的意义：copy一个已有的对象去初始化一个新的，类型相同的对象。新对象是已有对象的复制

Vec(const Vec&);

##### 参数必须为 const obj&，(1)复制构造函数定义了类的copy过程，copy并不改变原来的obj所以为const类型

##### (2)复制构造函数定义了copy的含义，把值传入复制构造函数中属于隐式复制，如果不是引用类型就是在递归调用复制构造函数。所以不能传递一个值。

##### 4、定义操作符 

return value          operator+操作符(argument)

(1)操作符是一个非成员函数，有多少操作数就又多少参数，第一个参数是左操作符，第二个参数是右操作符。

(2)操作符是一个成员函数，左操作数就是调用这个操作数的对象，实际的参数比操作数个数少1

(3)对元素进行读写的能力，意味着要对操作符需要两个版本的操作符，非const版本用来写，const版本用来读

例如：赋值操作符的定义

leftoperator&  operator=(const operator&)

5、赋值,复制,初始化的区别：

|  | 赋值| 初始化|
| --- | --- |
| 对象 |不会创建一个对象|创建一个新的对象|
| 值 |删除对象原先的值|不会删除对象原先的值|

复制：创建一个新的对象

赋值：删掉左操作数已有的值，用右操作数的值来替换。和operator =成员函数相关。

初始化：创建一个新的对象，并为这个对象提供一个初始值。使用=来初始化一个变量时，调用复制构造函数。发生在：变量声明，函数的参数列表和返回值（参数列表相当于一个函数内的局部变量，值传递。返回值相当于一个临时变量。)，类的初始化列表。和构造函数相关。

string str = "hello,world"是会调用string类的一个构造函数，参数为const char*类型来创建str对象。

函数的参数列表和返回值中的初始化：

先调用复制构造函数，把实参的副本复制到参数列表中，把返回值复制到一个临时对象上。

#### 注意：自我赋值的处理，因为赋值是销毁左操作数的已有的元素，返回使用的空间，赋予右操作数的值如果是自我赋值就相当于，先自我销毁，在赋予销毁后的空间，所以处理自我赋值非常重要。

6、析构函数：释放构造函数分配的所有资源。

~Vec(){

code segment;

}

7、new的缺陷：不仅会分配内存空间，而且会将内存空间初始化

8、

分配内存空间，和在内存中创建对象是两个不同的步骤

alloctor<T>类；

template<class T>

class alloctor{

​	public:

​		T* allocate(size_t);//分配指定类型的，但未进行初始化的内存；这块内存空间用来存储T类型的值，

并且返回一个T*的指针，但是这块内存中并没有任何对象。

​		void deallocate(T**,size_t);//释放未初始化的内存空间。释放T*指向的size_t大小的空间

​		void construct(T*,const T&);//在内存空间中，构造对象。复制T类型的对象值到未初始化的内存空间中。

​		destroy(T*);//销毁内存空间中的对象。调用对象的析构函数，使内存变为未初始化状态，但并不释放这块内存空间。

​		......

} 

uninitialized_copy(begin,end,des)：

把[begin,end）区间中的值，复制到des所指向的位置。des是未初始化的内存空间，函数会在这块内存中构造对象。

返回新区间末尾元素的下一个元素的地址。

unintialized_fill(begin,end,val):

在[begin,end)区间，用val的值来填充。

#### tips:

#### 1、在设计一个类时，根据如何使用这个类来确定类的接口

2、explicit 关键字 ：只有明确使用该构造函数时候，才会调用这个构造函数，否则无法使用

3、函数的返回值，不要返回局部变量的引用。

赋值操作符返回左操作数的引用。

4、this是指向成员函数操作的对象的指针，在类中定义的二元操作符中，this绑定在左操作符上面

5、当没有为类定义构造函数，析构函数时，编译器会为类自动合成这样一个函数。默认的操作是递归的进行，类A的成员B如果类型为一个类的话，会调用B的构造函数和析构函数。内置类型会像一个局部变量一样进行复制和赋值。

#### 特别注意：默认的析构函数仅仅会销毁一个指针，但是并不会释放指针指向的空间，这样会造成内存泄漏：指针指向的空间再也不能被回收利用。

6、析构函数，复制构造函数，赋值操作符三者缺一不可，因为析构函数会控制对象所拥有的资源的释放，而赋值操作符和复制构造函数会控制两个对象是否共享资源。

7、内存管理的策略：因为分配内存空间的代价很昂贵，所以当容器空间已满，需要添加一个新元素的时候，会分配当前使用空间的两倍内存空间。即分配比实际需要更多的内存空间。此策略需要三个指针，第一个指针first指向容器中的第一个元素，second指向容器中末尾元素的下一个位置，third指向容器内存空间的下一个位置。

## 第12章使类的对象像数值一样工作

重点：使用类的操作和类型转换上面，使得类的对象与C++内置类型的对象行为一致。

使用带有一个参数的构造函数来实现类型转换：

Str s = "hello";先调用Str的构造函数 Str(const char* c),将类型为const char*的“hello"转换为一个Str类型的临时对象，再赋值给s.

1、友元的应用场景：

二元操作符左操作数与第一个参数绑定，右操作数与第二个参数绑定。

成员操作符函数，左操作数与这个成员函数所属的对象绑定。

operator >>的 左操作数是 istream&，cin >> s 相当于cin.operator>>(s)
如果把>>操作数定义为str类的成员函数，则s.operator>>(cin) 相当于s >> cin,与标准库不相符。
所以operator>>是非成员函数，但是该操作符不能访问str类的数据，所以不能往data里面写。
解决方案：1、添加一个访问器函数，那么所有用户都可以向data里面写数据了，并不安全。
2、添加友元，友元具有和成员函数一样的权限可以访问类的私有成员。

（友元声明可以出现在类定义中的任何地方。友元相当于类的接口之一，所以把友元声明放在类定义的开头。）

3、

### 危险的类型转换

如果构造函数的参数是对象的一部分的话，那么该构造函数不应该是explicit.
如果构造函数是用来定义对象的结构的构造方式，而不是定义对象的内容的构造函数，那么该构造函数应该是explicit的。

如果一个构造函数被定义为explicit，那么只有显式地构造对象的时候才会调用这个构造函数，无法隐式地把表达式或者函数调用中的操作数转换为类的对象。

4、对于x+y表达式，编译器并不需要检查所有的类型以发现是否可以把x类型转换为一个含有operator+成员函数的类型。

#### 所以有这样一个限定：如果一个操作符是类的成员，那么左操作数不能是类型转换的结果。

有了这样一个限定，编译器只检查 x.operator+(y)或者非成员函数operator+

在二元操作符的设计中：把一个二元操作符设计成成员函数，会使得左右两边的操作数具有不对称性，右操作数可以是类型转换的结果，左操作数不能是自动类型转换的结果。

具体例子：x+y  a+=b  a=c

x+y,+这个二元操作符具有对称性：x+y,y+x,所以设计成非成员函数。

a+=b，这个二元操作符不具有对称性。所以可以把+=设计成成员函数。

a=c，为什么需要把赋值操作符设计成成员函数：1、把左操作数的类型限制为不能自动类型转换，如果左操作数可以进行自动类型转换，就会调用构造函数产生一个临时对象，然后把值赋值给一个临时对象，赋值操作之后，就无法访问刚刚赋值的对象了。



5、一个类的两种类型转换方式：

（1）、通过类的构造函数，把其他类型的对象转换为自己类型的对象

（2）、通过类型转换操作符，把自己类型的对象转换为其他类型。

operator target type()const{

​			;

}

if (cin  >>  x)    <==>   cin >> x; if(cin)    istream 会被类型转换为void\*，返回0或者系统定义的非0的void\*值来确定流的状态。

为什么不把istream类型转换为bool？

（1）、int x; cin << x;会产生，cin会被std::stream::operator bool()类型转换为bool类型,然后类型转换为一个int类型。最后结果将x左移若干位，然后丢弃这个值。

（2）这样使得一个istream对象可以作为一个条件式，也能阻止它成为一个算术值。



