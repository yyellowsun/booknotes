1、抛出一个exception,程序暂停在exception抛出的地方，然后将程序的控制权和
(包含调用者可用于对异常操作的信息的)exception object传递给异常处理程序部分。
2、domain_error 在<stdexcept>库中，表示函数的参数超过函数可接受的值域。
### 3、reference相当于变量的别名
##### 非const 的reference不能成为Const obj或 reference的引用
##### const的reference可以成为const or non-const的引用	
##### 当一个函数的形参的类型为const &的时候，有两个含义：
##### 直接传入实参，而不是value-copy，并且保证不会改变形参的值。
### 如：
##### const int &p = q;
##### int &r = p; 是不被允许的。
##### const int *p
##### int *const p 的区别？

4、lvalue是一个指向非临时对象的值。变量，引用都是一个左值。
5、EOF指示符通常意味着input失败
6、对于istream object的clear()，重置任何失败指示符，使得input可以继续
对于vector object的clear(),清空vector.
7、非const 引用的参数必须是个左值，因为如果非const 引用的参数是个临时变量的话，
函数运行完，这个临时变量就消失了，起不到引用的作用，在函数内对这个引用的一些改变
毫无意义。
8、一次只在一个代码段里面出现一个side effect
9、头文件是C++里面一个真实的文件，系统头不一定是一个文件。头文件应该使用完整的
名称，而不是using declarations
##  第七章map
1、关联数组：关联式容器的一种，当把一个键值对插入到结构中时，这个键会一直
伴随这个值，直到删除这个键值对为止。
2、map：关联数组的一种，map的key必须是可以通过比较进行排序的类型
其中每一个元素都是一个pair，first指向key，second指向value,
pair<const key,value>，为什么key是const类型的，

##### 如果不是const就隐式地说明我们可以改变元素的位置，这与关联式容器的自排序不相符
##### 关联式容器和序列式容器的区别，关联式容器是自排序的
4、当我们用一个从来没有遇到过的key来做map的索引的时候：map[key]
map会自动创建一个包含该key的元素，并且进行值初始化，例如：int类型的值初始化为0
#### （与容器元素相关的初始化都是值初始化,vector的值初始化，和不显式地提供初始值创建一个vector的效果一样，都是创建一个空vector）
14、
##第八章 泛型
##第九章 类
1、类的接口：类提供给 这个类的对象的 操作（就是操作这个类的对象的函数来访问数据）
2、打算让别人使用的代码尽可能少的包含必要的声明。
3、double grade() const；作为一个成员函数，这个const表示调用该成员函数不会改变
这个类的对象的任何数据成员。注意：只是保证不会改变这个成员函数所属的类的对象的
数据成员。
4、::生存空间操作符的使用, name space :: function name，通过这样来表明这个函数
所属的命名空间。如果name spcace空着不写，就表示这个函数不属于任何一个命名空间。
特别注意：如果在成员函数里面调用一个不属于该成员的同名函数，就必须：：function name这样写。
5、一个类的对象的成员函数（1）可以直接访问对象的数据元素。
                        (2)成员函数的调用里隐含着 一个 <成员函数所属的对象的引用> 的参数。
6、const关键字的理解：
double Student_info::grade() const{}：const 成员函数 表示成员函数不会修改它所操作的对象的数据成员。
double grade(const Student_info&){}:传入一个const参数，表明函数不会改变这个参数的值。
注意：如果把一个非const的对象std传给grade函数，grade(std)，那么std会被当作const对象来处理，此时就只能调用stu.grade()
而不能调用其他非const的成员函数。
const对象只能调用const 成员函数
7、什么时候设计成员函数：如果这个函数改变对象的数据成员时，就应该把这个函数设计为成员函数。
8、struct 和class的唯一区别：默认保护的方式不同。
struct会从{到第一个保护标签之前的所有成员视为public
class会从{到第一个保护标签之前的所有成员视为private
通常使用struct来表示简单的类型。
9、访问器函数：访问对象内部的数据成员的成员函数
10、构造函数：定义了对象如何初始化的函数。 如果没有定义构造函数就会使用编译器合成的构造函数
没有返回值，函数名与类名相同。
构造函数初始化对象的数据成员的规则：
    (1)类定义了构造函数，按照定义的构造函数来初始化
    (2)当创建的对象是局部变量时候，进行默认初始化(取决于变量的类型，如果一个变量的类型定义了如何默认初始化，就按照定义来，否则是不明确的值)
##### 当创建的对象和容器的元素相关的话，进行值初始化(内置类型值初始化为0)    场景：1、用来初始化容器的元素，2、作为给定长度容器的元素 3、map新添的一个元素，

(3)如果没有定义任何构造函数的类，对这个类的数据成员进行适当的默认初始化或者值初始化，数据成员的类型是个类的话，就递归的进行初始化。
11、默认构造函数：不带有任何参数的构造函数
构造函数的定义 Student_info::Student_info(): <初始化列表> {};初始化列表表示对象该如何初始化
创建一个对象进行的工作：1、系统为对象分配内存，2、使用构造函数的初始化列表，初始化对象，3、执行构造函数的函数体。
通过在初始化列表显式地进行初始化，可以避免在函数体进行两次初始化操作。
成员初始化的顺序取决于在类中声明的顺序。用数据成员b来初始化数据化成员a时，则必须a声明在b之前，安全的做法是在函数体里面进行初始化。




